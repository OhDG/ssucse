# 11.1 : Good Schema and Bad Schema

## Bad Schema Example 1

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/80651bdc-a740-4857-9255-39299a6f9b10/730d18b5-e98c-4e2a-9bbd-4ffeeb80aff4/image.png)

-   관계형 스키마
    -   테이블 이름, 속성 이름 및 무결성 제약으로 구성됨
    -   좋은 성질을 가지지 못한 나쁜 스키마
        -   데이터베이스 시스템 성능에 악영향을 미침
-   나쁜 스키마 mybadtable1
    -   course 테이블과 department 테이블을 합성하여 생성
    -   테이블의 인스턴스
        -   두 개 테이블의 자연 조인 연산을 하여 구함
    -   mybadtable1의 주 키는 cID
-   나쁜 테이블은 세 가지 이상(anomaly)을 가짐
    -   갱신 이상, 삭제 이상, 입력 이상

## An instance of mybadtable1

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/80651bdc-a740-4857-9255-39299a6f9b10/0dd45a34-bdf9-4e71-99c4-e9d23f4f69d3/image.png)

-   mybadtable1 인스턴스에서 세 가지 이상
    -   갱신 이상
        -   chairman, building, budget 속성 값이 deptName 값에 의존적 → 학과명이 반복될 때 해당 속성 값이 반복적으로 나옴
            -   그 속성 값에 갱신이 발생하면 반복적으로 나오는 모든 값을 동시에 갱신하여야 하는 현상
    -   삭제 이상
        -   과목 삭제로 인하여 과목 터플이 삭제되는 경우
            -   CS 학과가 개설하는 마지막 과목이 삭제가 되면, 해당 과목 정보가 삭제되는 것 외에도 학과 정보가 함께 삭제가 되는 현상
        -   학과에서 제공하는 마지막 과목이 삭제가 되더라도 학과 정보는 데이터베이스에 존재해야 함
            -   학과 정보가 함께 데이터베이스에서 영원히 삭제되는 것이 문제
        -   마지막 과목이 아닌 경우
            -   CS 학과의 경우 Databases 과목 및 Java 과목이 삭제되는 경우에는 삭제 이상이 발생하지 않음
                -   Databases와 Java 과목 삭제 후에 남아있는 마지막 과목(Data Structure 과목)을 삭제할 때 삭제 이상이 발생함
    -   입력 이상
        -   새로운 학과가 창설되어 학과에 대한 정보를 데이터베이스에 입력하고자 하여도 그 학과가 개설하는 과목이 없으면 학과 정보를 입력할 수 없는 현상
            -   주 키가 cID이므로

## Bad Schema Example 2

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/80651bdc-a740-4857-9255-39299a6f9b10/ab258d1f-8e08-42bf-be9f-b1e349234fc2/image.png)

-   나쁜 스키마 mybadtable2
    -   course 테이블과 room 테이블을 합성하여 생성함
    -   course 정보와 room 정보는 전혀 관련이 없는 데이터 → 두 테이블을 합성하면 두 테이블의 카티시안곱이 합성 테이블의 인스턴스가 됨
-   이 경우에 나타나는 세 가지 이상
    -   갱신 이상
        -   한 cID에 대하여 roomID가 반복적으로 나타남
            -   building과 capacity 값도 반복적으로 나타남
        -   그 결과 갱신 시에 반복되는 모든 값을 동시에 갱신해 주어야 함
    -   삭제 이상
        -   마지막 cID가 삭제되면 서로 관련이 없는 room 데이터도 함께 삭제가 되는 현상
    -   입력 이상
        -   서로 관련이 없는 cID와 roomID 값이 동시에 있어야 입력이 가능한 현상

## Design Goal

-   본 장의 목적
    -   주어진 관계 스키마가 좋은 스키마인지 결정함
    -   만약 주어진 관계 스키마가 좋지 않은 스키마이면
        -   주어진 스키마를 다수의 다른 관계 스키마로 분해
        -   그 경우 분해된 각 관계 스키마는 좋은 형태
        -   또한 분해 과정은 무손실 조인 분해여야 함
    -   함수 종속성과 다치 종속성을 이용하여 정규화 이론을 설명

## Functional Dependencies

-   함수 종속성
    -   유효한 관계 인스턴스에 대한 제약
    -   키 개념의 일반화라고도 볼 수 있음
    -   일부 속성의 값이 다른 속성의 값을 유일하게 결정하는 것을 의미함

## Functional Dependency Definition

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/80651bdc-a740-4857-9255-39299a6f9b10/fde80b45-4517-4399-b28f-8fb96ced72e5/image.png)

-   α, β는 속성의 일부분을 나타냄
-   유효한 관계 인스턴스에서 α 속성 값이 동일한 임의의 터플 두 개에서 β 속성 값이 항상 동일하면
    -   우리는 α는 β를 함수적으로 결정(또는 β는 α에 함수적으로 의존)한다고 함
-   예제에서
    -   A는 B를 함수적으로 결정하지만 (또는 B는 A에 함수적으로 의존)
    -   B는 A를 함수적으로 결정하지 않음
    -   A 속성 값이 같은 터플은 첫 번째와 두 번째 터플이고, 첫 번째와 두 번째 터플의 B 속성 값이 동일하며, 그 외에는 동일한 속성 값을 가지는 터플이 없으므로
        -   A는 B를 함수적으로 결정함
        -   같은 의미로 B는 A에 함수적으로 의존함
    -   두 번째와 세 번째 터플을 보면 B 속성이 같으나 A 속성 값이 상이하므로
        -   B는 A를 함수적으로 결정하지 않음

## FDs and Keys

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/80651bdc-a740-4857-9255-39299a6f9b10/1f3319d5-423b-47d2-ab8b-e6337836dd9f/image.png)

-   슈퍼 키
    -   관계 속성의 일부분으로서 전체 속성을 함수적으로 결정하는 속성
-   후보 키
    -   슈퍼 키의 성질을 만족하면서 동시에 슈퍼 키의 성질을 만족하는 속성의 서브셋이 없으면 이를 후보 키라고 함
    -   슈퍼 키 중에서 필요한 속성만을 가지는 것
    -   모든 속성을 함수적으로 결정
        -   이는 각 속성을 함수적으로 결정하는 것
-   “professor” 관계에서 pID가 후보 키이면
    -   pID 속성은 모든 속성을 결정함
    -   pID 속성이 모든 속성을 함수적으로 결정하는
        -   이는 pID 속성이 각 속성을 함수적으로 결정하는 것

## Use of Functional Dependencies

-   함수 종속성은 두 가지 방식으로 사용
    -   첫째, 주어진 관계 인스턴스의 유효성을 검사하는 데 사용할 수 있음
        -   특정 테이블 인스턴스가 주어진 함수 종속성을 만족하여 유효한지 여부를 판단할 수 있음
    -   둘째, 적법한 테이블의 제약 조건을 명시하는 데 함수 종속성을 사용할 수 있음
        -   테이블을 설계하고 속성 간의 함수 종속성을 명시하면, 그 테이블 인스턴스는 함수 종속성을 항상 만족해야 함

# 11.2 : Functional Dependency Theory

## Functional Dependency Theory

-   일반적으로 데이터베이스 설계자에 의하여 함수 종속성이 결정됨
    -   함수 종속성 간에 중복성이 존재할 수 있음
    -   데이터베이스 설계 과정에 나쁜 영향을 미치는 함수 종속성이 존재하기도 함

## Trivial Functional Dependencies

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/80651bdc-a740-4857-9255-39299a6f9b10/e4a007ce-9a63-4d70-a891-55a71bf1b558/image.png)

-   함수 종속성이 테이블의 모든 인스턴스에 대하여 만족이 되는 경우
    -   이러한 함수 종속성은 무의미(trivial)하다고 함
-   α와 β는 속성의 집합
    -   일반적으로 α가 β를 포함하는 슈퍼집합일 때
        -   α가 β를 함수적으로 결정하는 것은
            -   어떤 테이블 인스턴스에 대하여도 항상 만족을 함 → 이러한 함수 종속성은 무의미

## Closure of a Set of Functional Dependencies

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/80651bdc-a740-4857-9255-39299a6f9b10/ac64e8d0-8dc2-442b-bb69-3181782cbc6d/image.png)

-   함수 종속성은 다른 함수 종속성으로부터 유추할 수 있음
-   주어진 함수 종속성
    -   A → B
    -   B → C
        -   로부터 새로운 함수 종속성
            -   A → C를 유추할 수 있음
-   주어진 함수 종속성 집합으로부터 유추할 수 있는 모든 함수 종속성을 가진 집합을 함수 종속성 폐포(closure)라고 함
-   함수 종속성 폐포는 당연히 주어진 함수 종속성을 포함함
-   일반적으로 함수 종속성 폐포는 구하기가 쉽지 않음 → 앞으로 함수 종속성 폐포를 직접 구하여 사용하지 않음

## Armstrong’s Axioms

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/80651bdc-a740-4857-9255-39299a6f9b10/919a3b54-422c-437f-aa98-165420b30da9/image.png)

-   암스트롱 공리
    -   새로운 함수 종속성을 유추할 수 있는 추론 규칙(inference rule)
    -   세 가지 추론 규칙으로 구성됨
-   첫 번째 규칙 : 재귀성(reflexivity) 규칙
    -   무의미한 함수 종속성을 생성
-   두 번째 규칙 : 부가성(augmentation) 규칙
    -   주어진 함수 종속성에 동일한 속성을 양쪽에 추가하여도 됨
-   세 번째 규칙 : 이행성(transivity) 규칙
    -   추론의 이행성을 설명하는 것

## Example

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/80651bdc-a740-4857-9255-39299a6f9b10/c4ac7bda-3075-4804-93cb-fbe3a5546898/image.png)

-   테이블과 함수 종속성이 주어졌을 때 새로운 함수 종속성을 추론
-   "A → B"와 “B → H”에 대하여 이행성 규칙을 적용하면
    -   새로운 함수 종속성 “A → H”를 구할 수 있음
-   “A → C"에서 양쪽 편에 "G"를 부가하면
    -   ”AG→ CG"를 구함
    -   ”AG→ CG"와 주어진 ”CG→ I"를 이행적으로 적용하면
        -   ”AG→ I"를 구함

## Armstrong’s Axioms are sound and complete

-   추론 규칙은 항상 두 가지 사항(건전성 및 완전성)을 고려함
-   추론 규칙에서 건전함
    -   새롭게 생성되는 규칙이 유효하다는 의미
    -   암스토롱 공리를 이용하여 생성되는 모든 함수 종속성은 유효하므로 암스트롱 공리는 건전함
-   암스트롱 공리가 완전하다는 의미
    -   모든 유효한 함수 종속성을 암스트롱 공리를 이용하여 생성할 수 있다는 의미
    -   주어진 함수 종속성 집합으로부터 생성할 수 있는 모든 유요한 함수 종속성을 암스트롱 공리만 사용하면 모두 생성할 수 있다는 의미
-   암스트롱 공리의 건전성을 증명하기는 비교적 수월
    -   암스트롱 공리의 완전성을 증명하기는 매우 복잡하나 이미 증명이 됨

## Additional Inference Rules

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/80651bdc-a740-4857-9255-39299a6f9b10/f4eedc1b-6bc4-4c6a-84d3-8c32c14ca31b/image.png)

-   암스트롱 공리 외에도 새로운 함수 종속성을 생성하는 추가 규칙 세 가지
-   합성 규칙
    -   왼쪽 속성이 동일하면 오른쪽 속성의 합집합을 결정하는 함수 종속성을 생성함을 의미
-   분해 법칙
    -   왼쪽 속성이 오른쪽 속성의 일부분도 각각 결정함을 의미
-   암스트롱 공리는 완전함으로 추가되는 추론 규칙도 암스트롱 공리를 적용하여 유추할 수 있음

## Procedure for Computing F+

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/80651bdc-a740-4857-9255-39299a6f9b10/89c2b8e5-5828-435b-b32d-ba18593f1c53/image.png)

-   주어진 함수 종속성 폐포를 구하는 방법
    -   기본적으로 암스트롱 공리를 반복적으로 적용하는 것
        -   이를 더 이상 새로운 함수 종속성이 안 나올 때까지 적용하는 것
    -   항상 주어진 함수 종속성의 폐포를 구할 수 있음
        -   그 이유는 암스트롱 공리가 완전하기 때문
    -   이러한 방식은 함수 종속성 폐포를 구하는 이론적인 방법
        -   실질적으로는 상기 방식으로 함수 종속성 폐포를 구하지 않음

## Closure of Attribute Sets

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/80651bdc-a740-4857-9255-39299a6f9b10/3a57fd65-330c-4564-afed-8bc75b850e34/image.png)

-   속성 폐포(closure of attributes)
    -   주어진 속성이 함수적으로 결정할 수 있는 모든 속성
    -   주어진 속성에 주어진 함수 종속성을 적용하여 함수적으로 결정할 수 있는 모든 속성을 의미
-   속성 폐포를 구하는 알고리즘
    -   함수 종속성의 왼쪽 속성이 현재까지 구한 속성 폐포에 포함되어 있으면
        -   오른쪽 속성을 속성 폐포에 포함하는 방식
    -   이를 더 이상 새로운 속성이 나오지 않을 때까지 반복하는 아이디어

## Example of Attribute Set Closure

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/80651bdc-a740-4857-9255-39299a6f9b10/0632ef02-46c7-427f-a37b-b6ddb1f0ebd9/image.png)

-   주어진 테이블 R은 여섯 개의 속성을 가짐
    -   속성 AG의 폐포를 구하는 예제
        -   AG의 폐포는 AG가 결정하는 모든 속성을 구하는 것
        -   그 결과는 ABCGHI
            -   즉, 모든 속성
    -   속성 AG가 후보 키인가를 검증
        -   첫째, 속성 AG가 모든 속성을 결정하므로 슈퍼 키 조건을 만족함
        -   둘째, AG의 부분집합이 슈퍼 키 조건을 만족하는가
            -   부분 집합 A 또는 G 모두가 슈퍼 키 조건을 만족하지 않음 → AG는 후보 키

## Uses of Attribute Closure

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/80651bdc-a740-4857-9255-39299a6f9b10/a216f6ae-ae4c-40e4-b7c7-434236b1a66d/image.png)

-   속성 폐포를 사용하는 방법
    -   첫째, 주어진 속성이 슈퍼 키인지 검증할 때 사용
        -   주어진 속성의 폐포를 구하여 주어진 테이블의 전체 속성을 가지게 되면 그 속성은 슈퍼 키
    -   둘째, 주어진 함수 종속성이 유효한지 검증
        -   주어진 함수 종속성 “α→β”에 대하여 속성 α의 폐포에 β가 속하게 되면
            -   “α→β”는 유효한 함수 종속성
        -   이러한 방식은 주어진 함수 종속성의 폐포를 구하여 “α→β”가 속하는 지를 보는 방식보다 훨씬 간단하고 쉬움
    -   셋째, 두 번째 방식을 활용하여 함수 종속성의 폐포를 구함
-   속성의 폐포를 구하는 방식은 간단하고 쉬운 절차
    -   실질적으로 첫 번째와 두 번째 방식은 널리 사용되고 있음

## Canonical Cover

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/80651bdc-a740-4857-9255-39299a6f9b10/3d51349c-a698-4f98-94a4-d4b145f1477f/image.png)

-   사용자로부터 주어지는 함수 종속성 집합에는
    -   중복되는 함수 종속성이 존재하기도 함
    -   개별 함수 종속성에도 불필요한 속성을 가지기도 함
-   {A → B, B → C, A → CD} 예제
    -   A → CD 에서 A → C 및 A → D 가 유추됨
    -   A → C는 중복적으로 유추가 가능하여 필요 없음
-   {A → B, B → C, AC → D} 예제
    -   A → B 및 B → C에서 A → C가 유추됨
    -   A → C에서 A → AC이므로 A → D가 유추됨
    -   AC → D에서 속성 C가 필요 없음
-   정규 커버
    -   주어진 함수 종속성과 동일한 표현력을 가지면서(즉, 함수 종속성 폐포가 동일함), 가장 최소한의 속성 및 가장 적은 수의 함수 종속성을 가지는 집합
-   불필요한 함수 종속성이 존재하거나 불필요한 속성이 함수 종속성에 존재하는 함수 종속성 집합보다는
    -   동등한 정규 커버를 사용하여 데이터베이스 설계를 하는 것을 권장함

## How to Get Canonical Cover

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/80651bdc-a740-4857-9255-39299a6f9b10/4179a181-8eaf-4187-9e7c-4c9ea60cf1b0/image.png)

-   정규 커버를 구하는 기본적인 아이디어
    -   주어진 함수 종속성에 변화가 없을 때까지 합성 법칙을 적용하고
    -   동시에 주어진 함수 종속성에 불필요한 속성을 제거하는 방식
-   정규 커버를 구하는 알고리즘은 복잡함

## Canonical Cover Example

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/80651bdc-a740-4857-9255-39299a6f9b10/12385b18-572f-497d-be21-8e6dc8a3f0ae/image.png)

# 11.3 : Normal Forms

## Normal Forms

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/80651bdc-a740-4857-9255-39299a6f9b10/a404ead5-450f-44ed-ad4a-4156f856f186/image.png)

-   관계 정규화에는 총 6개의 정규화형이 있음
    -   제1정규형, 제2정규형, 제3정규형, BCNF, 제4정규형, 제5정규형
-   제1정규형, 제2정규형, 제3정규형 및 BCNF
    -   함수 종속성을 이용하여 정의됨
-   제4정규형
    -   다치 종속성을 이용하여 정의함
-   실질적으로 많이 사용되는 정규형
    -   제3정규형 및 BCNF
-   그 이상의 정규형은 실효성이 거의 없어 사용하지 않음

## First Normal Form (1NF)

-   관계형 데이터 모델
    -   속성 값으로 원자 값만을 허용함
    -   원자 값이 아닌 값에는
        -   집합, 리스트(list), 백(bag), 복합 속성(compound attribute) 등
-   도메인의 모든 값이 원자 값이면
    -   관계형 스키마는 제1정규형에 속함
    -   제1정규형은 관계 정의의 일부분이기도 함

## Various Functional Dependencies

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/80651bdc-a740-4857-9255-39299a6f9b10/a1edc8bd-ba21-4004-b9cb-0a5acfec4def/image.png)

-   주요 속성(prime attribute)
    -   임의의 후보 키에 속하는 속성
-   비주요 속성(nonprime attribute)
    -   그렇지 않은 속성
-   주어진 테이블에 다수 개의 후보 키가 존재하는 경우
    -   최소한 하나 후보 키에 속해도 주요 속성임
-   α, β, γ는 속성의 집합을 표시
    -   함수 종속성 "α → β"에서 α의 부분집합 γ에 대하여 "γ → β"이 성립하지 않으면
        -   "α → β"는 완전 함수 종속성
        -   β는 α 전체(α의 참부분 집합(proper subset)이 아닌)에 대하여 의존적인 함수 종속성을 완전 함수 종속성이라고 함
    -   완전 함수 종속성이 아닌 경우 즉, "α→ β"에서 α의 부분집합 γ만 가지고도 β를 결정할 수 함수 종속성을 부분 함수 종속성이라고 함
        -   이 경우는 "α → β" 외에도 "γ → β" (γ는 α의 참부분 집합)가 성립되는 경우
    -   이행 함수 종속성
        -   암스트롱 공리의 이행 규칙을 이용하여 생성되는 함수 종속성
        -   "α → β“ "β → γ“가 존재하는 경우
            -   α는 γ를 이행적으로 결정한다고 (또는 γ는 α에 이행적으로 의존적이라고) 함

## Second Normal Form (2NF)

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/80651bdc-a740-4857-9255-39299a6f9b10/e9cadca6-f949-4453-af93-b3833af36e60/image.png)

-   제2정규형
    -   제1정규형 중에서 모든 비주요 속성이 모든 후보 키에 완전 의존적이어야 함
    -   주어진 테이블에 후보 키가 다수 개이면
        -   모든 비주요 속성은 각 후보 키에 완전 의존적이어야 함
-   테이블 R의 후보 키는 (SSN, pNumber)
    -   비주요 속성인 eName이 후보 키에 부분적으로 의존
        -   eName은 SSN에는 완전 의존함
    -   테이블 R은 제2정규형이 아님
-   분해가 된 세 개의 테이블(R1, R2, R3)
    -   모든 비주요 속성이 후보 키에 완전 의존함
    -   모두가 제2정규형에 속함

## Example for 1NF and 2NF

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/80651bdc-a740-4857-9255-39299a6f9b10/e43a8713-a1c7-45f7-b829-e8cb52a14af1/image.png)

-   FIRST 테이블
    -   후보 키가 (S#, P#)
    -   비주요 속성인 City가 후보 키에 부분적으로 의존함 → 제2정규형이 아님
    -   세 가지 이상 현상이 발생함
        -   입력 이상
            -   공급자는 부품 번호가 없으면 공급자의 도시 등을 입력할 수 없음
                -   즉, 부품과 공급자 도시와는 아무런 관련이 없는 데이터인데 잘못된 테이블 스키마로 인하여 입력하지 못하는 현상
        -   갱신 이상
            -   City 속성은 공급자 번호에만 의존적 → 공급자 번호가 반복되면 동일한 City 속성 값이 반복적으로 테이블이 나타남
        -   삭제 이상
            -   공급자가 마지막 부품 공급을 중단하면 부품 공급과는 관련이 없는 공급자의 City 정보가 함께 삭제됨
-   주어진 테이블 FIRST를 SECOND와 SP 테이블로 분해
    -   SECOND와 SP 테이블 모두에서 비주요 속성이 후보 키에 완전 의존됨 → 제2정규형

## Third Normal Form (3NF)

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/80651bdc-a740-4857-9255-39299a6f9b10/ad0ecd3a-bab0-4063-a5f6-e17dc36ca18d/image.png)

-   제2정규형 중에서 비주요 속성이 모든 후보 키에 이행적으로 의존적이 아니면 제3정규형임
    -   의미적으로 동일하나 또 다른 제3정규형 정의
        -   모든 의미 있는 함수 종속성 “α → β”에서 α가 슈퍼 키이거나 또는 β가 주요 속성이어야 함
-   주어진 테이블 myEmpDept
    -   비주요 속성 Dname
        -   D#을 거쳐 후보 키 SSN에 의존적(즉, 이행적으로 의존) → myEmpDept 테이블은 제3정규형은 아님
    -   다만 비주요 속성이 후보 키에 완전 의존함 → 제2정규형은 됨
-   주어진 테이블을 두 개의 테이블(ED1 및 ED2)로 분해하면
    -   두 개의 테이블 모두가 제3정규형이 됨

## Example for 2NF and 3NF

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/80651bdc-a740-4857-9255-39299a6f9b10/f67925ec-7ed7-46ec-b625-b243d9c23e20/image.png)

-   SECOND 테이블
    -   후보 키가 S#
    -   비주요 속성인 Status
        -   후보 키에 이행적으로 의존적 → 제3정규형이 아님
    -   잘못된 스키마로 인하여 이상 현상이 나타남
        -   입력 이상
            -   S# 없이는 City에 대한 Status 정보를 입력할 수 없는 현상
                -   S#는 Status를 City 속성을 통하여 transitively 결정(determine)함
        -   갱신 이상
            -   City가 반복될 때마다 Status 값이 반복적으로 나오게 됨 → City에 대한 Status 값의 변경이 있으면 다수 개의 값을 동시에 갱신해야 하는 현상
        -   삭제 이상
            -   마지막 공급자를 삭제하면 공급자와 관련이 없고 City에 관련이 있는 Status 값도 함께 삭제되는 현상
-   SECOND 테이블을 SC 및 CS 테이블로 분해
    -   두 테이블 모두 제3정규형이 됨

## Boyce/Codd Normal Form (BCNF)

-   관계형 스키마가 모든 의미 있는 함수 종속성 “α → β”에서
    -   α가 슈퍼 키이면 BCNF 정규형이 됨
-   제3정규형 정의에서 나온 두 번째 조건(즉, α가 슈퍼 키가 아닌 경우 β가 주요 속성인 조건)
    -   을 삭제한 것이 BCNF 정규형 정의

## 3NF and BCNF Example

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/80651bdc-a740-4857-9255-39299a6f9b10/84477a63-b67c-4182-aaa1-57c00b096bfb/image.png)

-   MovieStudio 테이블의 함수 종속성 studioName → studioAddr
    -   studioName이 슈퍼 키도 아니고 studioAddr이 주요 속성도 아님 → MovieStudio는 제3정규형은 아님
    -   모든 비주요 속성(studioAddr 포함하여)이 후보 키(title, year)에 완전 의존적 → 제2정규형
-   두 개의 테이블 MovieStudio1, MovieStudio2로 분해를 하면
    -   두 개 테이블 모두 BCNF임

## All Binary Relations are in BCNF

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/80651bdc-a740-4857-9255-39299a6f9b10/6c2dc531-fb73-4e32-9eb5-e669ad1a96fa/image.png)

-   속성을 두 개만 가지는 테이블은 모두 BCNF임
-   속성을 두 개만 가지므로 더 이상 분해도 불가능
    -   분해 과정에서 속성을 두 개만 가지는 테이블이 나오면 더 이상 정규화 과정을 진행할 필요가 없음
-   총 4가지 경우가 가능함
    -   첫째, 관련 함수 종속성이 없는 경우
        -   (A, B)가 후보 키가 됨 → 의미 있는 함수 종속성이 없으므로 BCNF
    -   둘째, “A → B”는 성립하나 “B → A”가 성립하지 않으면
        -   후보 키는 A가 됨 → 함수 종속성의 왼쪽이 슈퍼 키이므로 BCNF
    -   셋째, 두 번째 경우와 유사하게 증명
    -   넷째, “A → B”와 “B → A”가 성립하는 경우
        -   후보 키가 A와 B가 됨 → 함수 종속성의 왼쪽이 모두 슈퍼 키이므로 BCNF

## Relationship among normal forms

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/80651bdc-a740-4857-9255-39299a6f9b10/db0de0b5-ccd0-4417-8100-fd78afceea14/image.png)

-   정규형 간의 관계
-   가능한 관계형 스키마 중에서 일부가 제1정규형
-   제1정규형 중에 일부가 제2정규형
-   제2정규형 중의 일부가 제3정규형
-   제3정규형 중의 일부가 BCNF 정규형
-   정규형은 서브셋 관계가 있음
    -   통상 우리가 스키마에 대한 정규형을 결정할 때
        -   적용되는 정규형 중에 가장 높은 단계의 정규형을 의미함
    -   예를 들어, 주어진 스키마가 제3정규형이라고 말하면
        -   주어진 스키마는 제3정규형 외에도 당연히 제1정규형, 제2정규형이 됨
        -   BCNF 정규형은 아닌 스키마
-   실세계에서는 제3정규형과 BCNF 정규형을 사용하는 것을 권장

## Practice 1

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/80651bdc-a740-4857-9255-39299a6f9b10/b21a009c-b218-4b3c-8665-34bf2c352629/image.png)

-   스키마와 관련 함수 종속성이 주어지고 주어진 스키마에 대한 정규형을 결정하는 문제
    -   이러한 문제를 접근하는 방법
        1. 모든 후보 키를 구한다
        2. 주요 속성과 비주요 속성을 구한다
        3. 주어진 스키마에 대한 정규형을 판별한다
-   나쁜 스키마의 전형적인 사례
    -   속성 A, C, D와 속성 B, E, F는 전혀 관련이 없음
    -   예를 들면
        -   R(학번, 이름, 주소, 국가, 수도, 인구) 테이블에서 학생에 대한 데이터와 국가에 대한 데이터가 관련이 없는 경우
        -   해당 학생이 어떤 국가에 속한다는 등 관련이 없는 경우여야 함
        -   이러한 경우에 아래와 같은 함수 종속성이 존재
        -   학번 → 이름 주소
        -   국가 → 수도 인구
        -   관련이 없는 데이터를 동일 테이블에 저장함 → 여러 가지 이상이 발생

## Practice 2

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/80651bdc-a740-4857-9255-39299a6f9b10/1f6174dc-bab9-4b4d-863e-e57639a04d3c/image.png)

-   비주요 속성 간에 함수 종속성(C → D)이 존재함
    -   이러한 함수 종속성은 여러 가지 이상(anomaly)를 발생시킴
-   속성 D는 속성 C에만 의존적 → 속성 D 값이 반복되면 속성 C 값도 반복이 됨
    -   갱신 이상
-   속성 AB 값이 없으면 속성 C에만 의존적인 속성 D 값을 테이블에 입력할 수 없음
    -   입력 이상
-   속성 C에 대한 마지막 터플이 삭제되면 속성 D 값도 함께 삭제됨
    -   삭제 이상
-   스키마 설계 시에 비주요 속성 간의 함수 종속성은 피해야 하는 사항임

## Practice 3

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/80651bdc-a740-4857-9255-39299a6f9b10/a31a7b8e-16fe-46f2-9af9-98d474a74ffa/image.png)

## Practice 4

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/80651bdc-a740-4857-9255-39299a6f9b10/e093a311-aafe-4526-9cc9-229a20a71b09/image.png)

-   스키마에 존재하는 D → B 함수 종속성
    -   속성 D는 후보 키는 아니지만 속성 B가 주요 속성
-   후보 키가 아닌 속성이 주요 속성을 함수적으로 결정하는 함수 종속성을 허용하는 것이 제3정규형
    -   BCNF는 이를 허용하지 않음

## Practice 5

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/80651bdc-a740-4857-9255-39299a6f9b10/659eae1d-442b-4f34-bff1-064ccb3a340f/image.png)

-   연습 4와 차이점
    -   D → A 함수 종속성으로 인하여 후보 키가 속성 A 또는 속성 D가 된다는 것
    -   모든 함수 종속성에서 왼쪽 부분이 후보 키가 되는 BCNF 조건을 만족함

## Practice 6

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/80651bdc-a740-4857-9255-39299a6f9b10/560a6604-9aa2-4d4f-bd4c-9aa5217fff9b/image.png)

-   후보 키 A가 모든 속성을 결정함
-   비주요 속성 간에 함수 종속성이 없는 스키마
-   연관되는 데이터가 테이블 하나에 모여있는 좋은 스키마

## Practice 7

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/80651bdc-a740-4857-9255-39299a6f9b10/c5ff91dc-15ac-435c-8d5a-0292c622871b/image.png)

-   myInfo(주민등록번호, 여권번호, 운전면허번호, 군번, 이름)
    -   주민등록번호, 여권번호, 운전면허번호, 군번 등은 사람마다 값이 다름

# 11.4 : Decomposition and Design

## Goals of Normalization (Revised)

-   R은 주어진 관계형 스키마
-   F는 주어진 함수 종속성의 집합
-   함수 종속성을 이용하는 정규화의 목표
    -   첫째, 주어진 R이 좋은 스키마인지 결정함
    -   둘째, 주어진 스키마가 좋은 스키마가 아니면 분해 연산을 통해 다수 개의 작은 관계형 스키마로 변형함
        -   생성된 작은 스키마는 각각이 좋은 스키마여야 함
        -   분해 과정은 무손실 조인 분해(lossless join decomposition)이어야 함
            -   함수 종속성을 보존하는 분해이면 더 좋음

## Example of a Lossy Decomposition

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/80651bdc-a740-4857-9255-39299a6f9b10/3698d5d6-49ba-45f4-a11c-34d7d5fa1c77/image.png)

-   무손실 조인(lossless join) 분해의 반대 분해
    -   손실 조인 분해(lossy join decomposition, 또는 간단히 lossy decomposition)
    -   위 슬라이드는 손실 분해
-   employee 테이블을 두 개의 테이블로 분해하는 경우
    -   분해가 된 테이블의 터플은 원 테이블에서 투영 연산을 통하여 구함
        -   즉, 원 테이블에서 ID와 name 속성에 대하여 투영 연산을 하면 분해된 첫 번째 테이블에 대한 터플을 구할 수 있음
-   분해된 두 개의 테이블을 가지고, 원래 테이블을 생성하기 위하여 자연 조인을 실행하면
    -   마지막 테이블이 생성됨
        -   원 테이블에 없는 새로운 터플(spurious tuples)을 가지고 있음
            -   마지막 테이블의 두 번째와 세 번째 터플은 원래 테이블에 없는 터플
            -   분해 및 조인 연산 과정에서 부가적으로 생성된 터플
-   분해 과정에서 spurious 터플이 생기게 되는 손실 조인 분해를 안 하려고 함
    -   모든 분해는 spurious 터플이 안 생기는 무손실 조인 분해여야 함

## Example of Lossless-Join Decomposition

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/80651bdc-a740-4857-9255-39299a6f9b10/b7b22d51-a401-427c-b16d-a3df6ca8c95c/image.png)

-   무손실 조인 분해
-   주어진 테이블을 두 개의 테이블로 분해한 후, 투영 연산을 통하여 해당 터플을 구함
-   그 후 분해된 두 개의 테이블에 대하여 자연 조인 연산을 하면
    -   원래 테이블과 동일한 테이블을 생성함 → 무손실 조인 분해
-   무손실 조인 분해를 만족하기 위해서는
    -   분해된 테이블의 공통 속성(여기서는 속성 “B”)이 분해된 테이블 중 적어도 하나에서 주 키여야 함

## Lossless-join Decomposition

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/80651bdc-a740-4857-9255-39299a6f9b10/76bbb822-bfb4-4f35-ac75-649641097f2e/image.png)

-   테이블이 두 개의 테이블로 분해가 되는 경우의 무손실 조인 분해 정의
-   하나의 테이블이 두 개의 테이블로 분해되는 경우, 무손실 조인 분해가 되기 위해서는
    -   분해된 테이블 공통 속성이 분해된 테이블 두 개 중의 하나에서 해당 속성 모두를 결정하여야(즉, 슈퍼 키) 함
        -   이 조건은 분해가 무손실 조인 분해가 되기 위한 충분 조건이 됨
        -   만약 모든 제약이 함수 종속성이면(즉, 다치 종속성이 없으면) 필요 조건이 되기도 함
        -   이러한 무손실 조인 분해 조건은 하나의 테이블이 두 개의 테이블로 분해가 되는 경우에만 해당됨
            -   세 개 이상의 테이블로 분해가 되는 경우에는 좀 더 복잡한 조건이 있음

## Dependency Preservation

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/80651bdc-a740-4857-9255-39299a6f9b10/01375fd3-5ed1-47bf-bcb4-65141247ef3f/image.png)

-   테이블 R이 R1, ..., Rn으로 분해가 되는 경우, 주어진 함수 종속성 F의 폐포 중에서 Ri 에 속하는 속성만을 가진 함수 종속성을 Fi라고 하면
    -   분해가 함수 종속성을 보전하려면, 각 Fi의 합집합의 폐포가 원래 주어진 함수 종속성의 폐포와 동일해야 함
    -   분해가 된 작은 테이블에 관련이 있는 함수 종속성만을 가지고 폐포를 생성하여도
        -   원래 주어진 함수 종속성의 폐포와 동일하다면, 분해 과정에서 없어지는 함수 종속성이 없음 → 해당 분해는 함수 종속성을 보존함
-   함수 종속성이 보존되지 않는 분해이면
    -   주어진 함수 종속성을 확인하기 위하여 분해된 테이블 간의 자연 조인 연산을 해야 함
        -   자연 조인 연산은 시간과 자원을 소모하는 비싼 연산임

## Testing for Dependency Preservation

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/80651bdc-a740-4857-9255-39299a6f9b10/91080b0f-b339-4929-b05a-a4b0b8d36e5a/image.png)

-   테이블 분해 시에 함수 종속성의 보존 여부를 확인하는 알고리즘
-   함수 종속성 “α → β”의 보존성 여부를 판단하기 위해서는
    -   분해된 테이블 Ri 각각에 대하여 for-loop을 수행해야 함
    -   for-loop
        -   Ri와 현재까지 구한 속성과의 교집합에 대하여 속성 폐포를 구하고
        -   구한 속성 폐포를 Ri와 다시 한 번 더 교집합을 구하여 (즉, 속성 폐포 중에서 Ri에 나오는 속성만을 구하여) 변수 t에 저장함
        -   즉, 하나의 단일 테이블에 속하는 속성에 한정하여 속성 폐포를 구함
-   이러한 알고리즘을 모든 함수 종속성 각각에 적용해야 함
    -   모든 함수 종속성이 보존되어야 함
-   이 방식은 속성의 폐포를 활용하는 알고리즘으로서 다항시간(polynomial time)이 소요됨
    -   만약 함수 종속성의 폐포를 활용한다면 지수시간(exponential time)이 소요됨

## Decomposition Example

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/80651bdc-a740-4857-9255-39299a6f9b10/94b22d8e-9caa-4f9d-9be7-a3218a96858c/image.png)

-   첫 번째 분해
    -   무손실 조인 분해
    -   공통 속성(B)이 R2 테이블에서 속성 모두를 결정함
    -   “A → B” 함수 종속성은 R1 테이블에서 적용
    -   “B → C” 함수 종속성은 R2 테이블에서 확인
-   두 번째 분해
    -   무손실 조인 분해
    -   공통 속성(A)이 R1 테이블에서 속성 모두를 결정함
    -   “B → C” 함수 종속성을 확인하기 위해서는
        -   R1 테이블과 R2 테이블을 자연 조인 연산해야 함
            -   이러한 과정은 시간과 비용이 들어감 → 함수 종속성이 보존되지 않는 분해

## Testing for BCNF

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/80651bdc-a740-4857-9255-39299a6f9b10/9429cd57-3fef-4faf-9ee4-e4c95a17d088/image.png)

-   테이블 스키마가 BCNF 정규형인지를 확인하기 위해서는
    -   각 함수 종속성에 대하여 슈퍼 키 여부를 확인해야 함
    -   함수 종속성이 주어지면
        -   이론적으로는 주어진 함수 종속성의 최소 커버를 구한 후에 최소 커버에 속하는 각 함수 종속성에 대하여 슈퍼 키 여부를 확인하면 됨
        -   함수 종속성의 최소 커버를 구하는 것은 복잡한 계산을 요하는 어려운 작업 → 일반적으로 최소 커버를 구하여 BCNF 확인 여부를 결정하지 않음
-   BCNF를 시험하기 위해서는
    -   주어진 함수 종속성만을 가지고 슈퍼 키 여부를 결정해도 됨
    -   주어진 함수 종속성이 슈퍼 키 여부를 위반하지 않는다면
        -   주어진 함수 종속성의 폐포에 속하는 함수 종속성도 슈퍼 키 여부를 위반하지 않기 때문
    -   그러나 분해가 된 작은 테이블에 대한 BCNF 시험
        -   주어진 함수 종속성만을 검사하면 안됨
    -   예를 들어, 테이블 R(A, B, C, D, E)이 R1(A, B)와 R2(A, C, D, E)로 분해되었을 때
        -   R2(A, C, D, E)에만 속하는 주어진 함수 종속성이 없음 → R2가 BCNF라고 판정하면 안됨
        -   주어진 함수 종속성에는 나타나지 않았지만 폐포에 속하는 “AC → D”로 인하여 R2는 BCNF가 아님

## Testing Decomposition for BCNF

-   분해 시에 분해가 된 작은 테이블 Ri에 대한 BCNF 시험 여부는 다음의 두 가지 방법 중의 하나를 사용함
    -   첫째 방식
        -   Ri에 속하는 속성만으로 구성된 모든 함수 종속성을 구하여 슈퍼 키 여부를 확인하는 방법
        -   함수 종속성의 폐포를 구해야 함 → 실용적인 방식은 아님
    -   둘째 방식
        -   속성의 폐포를 활용하는 방법
        -   Ri에 속하는 속성의 모든 서브셋 속성 α에 대하여 속성의 폐포를 구함
            -   구한 속성 폐포가 Ri의 모든 속성을 가지고 있으면 α는 슈퍼 키 → BCNF 조건을 만족함
            -   구한 속성 폐포에 α를 제외한 속성이 없으면 “α → α”인 경우 → 무의미한 함수 종속성이므로 BCNF 조건을 만족함
            -   임의의 속성 β(단, β는 Ri의 모든 속성이 아님)를 함수적으로 결정 → “α → β”가 성립되어 BCNF 조건을 만족하지 않음

## Example of BCNF Decompostion

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/80651bdc-a740-4857-9255-39299a6f9b10/2a6026c2-1679-4993-b127-186eee405c37/image.png)

-   테이블 R과 함수 종속성을 이용하여 후보 키를 구하면
    -   속성 A가 후보 키가 됨
-   테이블 R은 BCNF가 아님
    -   함수 종속성 “B → C”에서 B가 슈퍼 키가 아니기 때문
-   테이블 R을 R1(B, C)과 R2(A, B)로 분해를 하면
    -   R1과 R2 모두 BCNF에 속함
    -   공통속성 B
        -   R1 테이블에서 후보 키 → 무손실 조인 분해
    -   함수 종속성 “A → B”는 R2 테이블에서만 검증이 됨
    -   함수 종속성 “B → C”는 R1 테이블에서만 검증이 됨
        -   함수 종속성이 보존되는 분해

## BCNF and Dependency Preservation (1/2)

-   하나의 테이블에 적용되는 함수 종속성
    -   확인하기가 비교적 수월함
-   두 개 이상의 테이블에 적용되는 함수 종속성
    -   확인하기에 비용이 비쌈
    -   자연 조인 연산을 수행해야함
        -   조인 연산은 관계 대수 연산 중에서 비싼 연산
-   주어진 모든 함수 종속성을 확인하기 위하여
    -   분해된 각각의 테이블에만 속하는 함수 종속성을 확인해도 충분한 경우를 만족하는 성질
        -   함수 종속성이 보존된다고 함
-   BCNF 정규형을 구하기 위하여 테이블을 분해하는 경우
    -   함수 종속성을 보존하지 못하는 경우가 있음
    -   이 경우 사용자는 함수 종속성을 보존하면서 그 대신 BCNF보다 하위 정규형인 제3정규형을 사용할 수도 있음

## BCNF and Dependency Preservation (2/2)

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/80651bdc-a740-4857-9255-39299a6f9b10/01042c89-245c-4188-be06-e3971c9f3417/image.png)

-   “L → K” 함수 종속성
    -   L이 슈퍼 키가 아님 → BCNF가 아님
-   테이블을 “L → K”를 이용하여 분해하면
    -   무손실 조인 분해를 위하여 공통 속성이 분해된 하나의 테이블에서는 슈퍼 키가 되게 해야 함
        -   R1(L, K) 및 R2(L, J)
            -   R1과 R2는 모두가 BCNF
            -   함수 종속성 “JK → L”을 확인하기 위해서는 분해된 두 테이블을 조인해야 함 → 함수 종속성이 보존되지 않는 분해

## Third Normal Form: Motivation

-   BCNF 정규형은 함수 종속성을 보존하는 분해를 지원하지 않으며, 만약 함수 종속성에 대한 효과적인 검증이 중요한 응용에서는
    -   BCNF형 대신에 조건이 완화된 제3정규형을 사용
-   제3정규형
    -   테이블 내에 값 중복성에 의한 이상(anomalies)이 존재함
    -   함수 종속성이 항상 보존되는 분해가 가능함
        -   제3정규형으로 분해를 하면 모든 함수 종속성
            -   하나의 테이블 내에서 검증이 가능
-   제3정규형을 목표로 하는 분해
    -   항상 무손실 조인 분해와 함수 종속성을 보존하는 분해

## There are some redundancy in 3NF!

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/80651bdc-a740-4857-9255-39299a6f9b10/f1b4b632-7b32-4c29-882a-b3a0b0a9e6c5/image.png)

-   함수 종속성 “L → K”
    -   L이 후보 키가 아니지만 K가 주요 속성(prime attribute)임 → 제3정규형에 속함
-   인스턴스가 함수 종속성을 만족하는지
    -   인스턴스에는 “L→ K” 함수 종속성에 의한 중복성이 있음 → 이로 인하여 세 가지 이상이 발생할 수 있음

## Testing for 3NF

-   제3정규형에 대한 시험 시에도
    -   주어진 함수 종속성만을 가지고 검증을 하면 됨
    -   주어진 함수 종속성의 폐포를 구하여 폐포에 속하는 모든 함수 종속성에 대하여 제3정규형 시험을 할 필요는 없음
-   함수 종속성의 왼쪽이 슈퍼 키가 아니면 오른쪽 속성이 주요 속성인지를 확인해야 함
    -   이를 위하여 테이블의 후보 키를 구하는 과정이 필요
        -   후보 키를 구하기 위해 전체 속성의 서브셋에 대하여 속성의 폐포를 구해야 함
            -   이 과정은 다소 비싼 연산임
-   제3정규형을 시험하는 과정
    -   NP-하드(NP-hard) 연산
-   제3정규형으로 분해하는 과정
    -   다항시간(polynomial time)에 수행할 수 있음

## Comparison of BCNF and 3NF

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/80651bdc-a740-4857-9255-39299a6f9b10/e92cabb1-ac96-4adf-b5e8-47561c176b00/image.png)

-   가능하면 BCNF형을 사용하는 것을 권장
-   다만 함수 종속성 보존이 중요한 응용 → 제3정규형을 사용해도 됨
-   실제 데이터베이스 응용에서는 제3정규형 또는 BCNF이 가장 널리 사용되는 정규형임

## Database Design (1/3)

-   관계형 데이터베이스 시스템 설계 목표
    -   BCNF형 사용
    -   무손실 조인 분해
    -   함수 종속성 보존
        -   이를 모두 달성할 수 없으면
            -   함수 종속성을 포기하거나
            -   제3정규형을 사용
-   SQL 표준에는
    -   함수 종속성을 직접적으로 명시하는 방법이 없음
    -   함수 종속성을 명시하는 문장도 없음
    -   함수 종속성을 임의의 테이블에 확인하는 기능 또한 없음
    -   이론적으로 사용자는 assertion 기능을 이용 → 함수 종속성을 표현할 수 있음
        -   상용 데이터베이스 시스템에서는 assertion 기능을 아직까지는 지원하지 않고 있음

## Database Design (2/3)

-   각종 테이블은 다음과 같은 상황으로 주어질 수 있음
    -   첫째, 테이블이 ER 다이어그램의 변환 과정에서 생성되었다고 볼 수 있음
    -   둘째, 모든 속성을 포함하는 아주 거대한 테이블(일명 우주 테이블)일 수도 있음
    -   셋째, 정규화 과정에서 생성되는 테이블일 수도 있음
    -   넷째, 테이블을 정의하는 임의의 설계 과정에서 생성되는 테이블일 수도 있음

## Database Design (3/3)

-   ER 데이터모델로 데이터베이스를 설계하는 경우
    -   개체를 정확히 결정하게 되면 ER 다이어그램에서 생성되는 테이블은 더 이상 정규화 과정이 필요 없게 됨
-   불완전한 실제 설계 과정에서는
    -   개체 키가 아닌 속성에서 다른 속성을 결정하는 함수 종속성이 존재할 수 없음
    -   이 경우에는 문제의 함수 종속성에 있는 속성만을 가지고 새로운 테이블을 생성해야 함
-   관계성 집합으로부터 생성된 테이블에서도
    -   키가 아닌 속성이 다른 속성을 결정하는 함수 종속성이 존재할 수 있음
        -   드물게 나타남
            -   대부분의 관계성 집합으로부터 생성되는 테이블은 두 개의 속성만을 가지기 때문

## Denormalization for Performance

-   정규화 과정
    -   주어진 테이블이 좋은 성질을 가지도록 작은 테이블로 분해하는 과정
-   주어진 테이블을 작은 테이블로 분해를 계속하면
    -   관련 있는 정보를 함께 검색하기 위하여 두 개 이상의 테이블을 조인하여야 하는 경우가 발생함
    -   조인은 비싼 연산으로 시간이 많이 소요됨
    -   데이터베이스 성능을 위하여 정규화된 테이블을 다시 합치는 소위 역정규화 과정을 하기도 함
-   역정규화가 요구되는 상황
    -   데이터베이스 성능이 데이터 중복에 의한 이상 현상보다 더 중요할 경우
-   데이터베이스 응용에 따라 데이터베이스 설계자는 역정규화를 적용함
    -   이에 대한 구체적인 이론은 존재하지 않음
    -   데이터베이스 응용 환경과 설계자의 경험에 의거하여 역정규화를 적용할 수도 있음
-   정규화된 테이블을 다시 합치는 역정규화가 적합하지 않을 때에는
    -   실체화된 뷰(materialized view)를 활용할 수 있음
        -   일반 뷰와 다르게 뷰 테이블이 소속 터플을 항상 구체적으로 가지고 있음 → 질의를 수행하기 위하여 추가적인 조인 연산이 필요 없음
